<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模板化墙面砖块计算器 (带本地保存)</title>
    <style>
        /* General Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1, h2, h3 {
            margin-top: 0;
            color: #1a73e8;
            padding-bottom: 10px;
        }
        h1, h2 { border-bottom: 2px solid #e0e0e0; }
        h3 { border-bottom: 1px solid #eee; font-size: 1.1em; margin-bottom: 10px; }


        .input-group, .tile-type, .option-group {
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }
        .row-template-group {
             display: grid;
             grid-template-columns: 60px 1fr;
             gap: 5px 10px;
             align-items: center;
        }

        label {
            font-weight: 500;
            flex-shrink: 0;
        }

        input[type="number"], select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            width: 100%;
        }
        input[type="number"] { width: 65px; }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: #1a73e8;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            margin-top: 10px;
        }
        
        button.remove-btn { background-color: #e94560; padding: 5px 10px; width: auto; margin-top: 0; }
        button.remove-btn:hover { background-color: #c73049; }
        #addTile { background-color: #34a853; }
        #addTile:hover { background-color: #2c8f45; }
        
        #wallCanvas { border: 1px solid #ccc; background-color: #f0f0f0; max-width: 100%; height: auto; }
        #results-container { list-style-type: none; padding: 0; }
        #results-container li { background-color: #e8f0fe; padding: 10px; border-radius: 4px; margin-bottom: 5px; display: flex; align-items: center; gap: 10px; }
        .color-box { width: 20px; height: 20px; border: 1px solid #ccc; border-radius: 3px; flex-shrink: 0; }

        /* Responsive Layout */
        .controls-container, .canvas-container { width: 100%; }
        @media (min-width: 1001px) {
            body { flex-wrap: nowrap; }
            .controls-container { width: 450px; flex-shrink: 0; display: flex; flex-direction: column; gap: 20px; }
            .canvas-container { flex-grow: 1; }
            button { width: auto; margin-top: 0; }
        }
    </style>
</head>
<body>

<div class="controls-container">
    <div class="panel">
        <h1>模板化墙面砖块计算器</h1>
        
        <h2>1. 墙面尺寸</h2>
        <div class="input-group">
            <label>墙面宽度:</label> <input type="number" id="wallWidth" value="530" step="any">
        </div>
        <div class="input-group">
            <label>墙面高度:</label> <input type="number" id="wallHeight" value="1070" step="any">
        </div>
        
        <h2>2. 布局模式定义</h2>
        <div id="row-templates">
            <h3>最底行（循环）</h3>
            <div class="row-template-group">
                 <label for="cycleRow2Head">头砖:</label> <select id="cycleRow2Head"></select>
                 <label for="cycleRow2Main">主循环砖:</label> <select id="cycleRow2Main"></select>
                 <label for="cycleRow2Tail">尾砖:</label> <select id="cycleRow2Tail"></select>
            </div>
            <h3>自下向上第二行（循环）</h3>
            <div class="row-template-group">
                <label for="cycleRow1Head">头砖:</label> <select id="cycleRow1Head"></select>
                <label for="cycleRow1Main">主循环砖:</label> <select id="cycleRow1Main"></select>
                <label for="cycleRow1Tail">尾砖:</label> <select id="cycleRow1Tail"></select>
            </div>
            <h3>首行 (固定)</h3>
            <div class="row-template-group">
                <label for="firstRowHead">头砖:</label> <select id="firstRowHead"></select>
                <label for="firstRowMain">主循环砖:</label> <select id="firstRowMain"></select>
                <label for="firstRowTail">尾砖:</label> <select id="firstRowTail"></select>
            </div>
        </div>

        <h2>3. 砖块类型定义</h2>
        <div id="tileTypesContainer">
            <!-- Bricks will be loaded from localStorage or default here -->
        </div>
        <button id="addTile">添加砖块类型</button>
    </div>

    <div class="panel">
        <h2>4. 用量统计</h2>
        <ul id="results-container"></ul>
    </div>
</div>

<div class="panel canvas-container">
    <h2>5. 效果预览</h2>
    <canvas id="wallCanvas" width="1000" height="800"></canvas>
</div>

<script>
// --- CORE SCRIPT ---

const STORAGE_KEY = 'wallCalculatorState';

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('addTile').addEventListener('click', () => {
        const newTileType = document.createElement('div');
        newTileType.className = 'tile-type';
        newTileType.innerHTML = `<label>砖块:</label><input type="number" class="tileWidth" placeholder="宽"><span>x</span><input type="number" class="tileHeight" placeholder="高"><button class="remove-btn" onclick="this.parentElement.remove(); updateAndRedraw();">移除</button>`;
        document.getElementById('tileTypesContainer').appendChild(newTileType);
        updateAndRedraw();
    });

    // Any change should trigger a full update and save cycle
    document.body.addEventListener('change', (event) => {
        if (event.target.matches('input, select')) {
            updateAndRedraw();
        }
    });

    loadState(); // Load saved data first
    updateAndRedraw(); // Then run initial calculation with loaded or default data
});

function updateAndRedraw() {
    updateTileLabels();
    populateBrickSelects();
    calculateAndDraw();
    saveState(); // Save state after every update
}


// --- LOCAL STORAGE FUNCTIONS ---

function saveState() {
    const bricks = [];
    document.querySelectorAll('.tile-type').forEach(el => {
        const width = el.querySelector('.tileWidth').value;
        const height = el.querySelector('.tileHeight').value;
        if (width && height) {
            bricks.push({ width, height });
        }
    });

    const state = {
        wallWidth: document.getElementById('wallWidth').value,
        wallHeight: document.getElementById('wallHeight').value,
        bricks: bricks,
        templates: {
            first: { head: document.getElementById('firstRowHead').value, main: document.getElementById('firstRowMain').value, tail: document.getElementById('firstRowTail').value },
            cycle1: { head: document.getElementById('cycleRow1Head').value, main: document.getElementById('cycleRow1Main').value, tail: document.getElementById('cycleRow1Tail').value },
            cycle2: { head: document.getElementById('cycleRow2Head').value, main: document.getElementById('cycleRow2Main').value, tail: document.getElementById('cycleRow2Tail').value }
        }
    };

    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function loadState() {
    const savedStateJSON = localStorage.getItem(STORAGE_KEY);
    const container = document.getElementById('tileTypesContainer');

    if (!savedStateJSON) {
        // No saved state, create default bricks
        container.innerHTML = `
            <div class="tile-type"><label>砖块 1 (A):</label><input type="number" class="tileWidth" value="200"><span>x</span><input type="number" class="tileHeight" value="100"><button class="remove-btn" onclick="this.parentElement.remove(); updateAndRedraw();">移除</button></div>
            <div class="tile-type"><label>砖块 2 (B):</label><input type="number" class="tileWidth" value="130"><span>x</span><input type="number" class="tileHeight" value="100"><button class="remove-btn" onclick="this.parentElement.remove(); updateAndRedraw();">移除</button></div>
            <div class="tile-type"><label>砖块 3 (C):</label><input type="number" class="tileWidth" value="176.67"><span>x</span><input type="number" class="tileHeight" value="80"><button class="remove-btn" onclick="this.parentElement.remove(); updateAndRedraw();">移除</button></div>
        `;
        return;
    }

    const state = JSON.parse(savedStateJSON);

    document.getElementById('wallWidth').value = state.wallWidth || '530';
    document.getElementById('wallHeight').value = state.wallHeight || '1070';

    container.innerHTML = ''; // Clear container before loading
    if (state.bricks && state.bricks.length > 0) {
        state.bricks.forEach(brick => {
            const newTileType = document.createElement('div');
            newTileType.className = 'tile-type';
            newTileType.innerHTML = `<label>Brick:</label><input type="number" class="tileWidth" value="${brick.width}"><span>x</span><input type="number" class="tileHeight" value="${brick.height}"><button class="remove-btn" onclick="this.parentElement.remove(); updateAndRedraw();">移除</button>`;
            container.appendChild(newTileType);
        });
    }

    updateTileLabels();
    populateBrickSelects();

    if (state.templates) {
        document.getElementById('firstRowHead').value = state.templates.first.head || '';
        document.getElementById('firstRowMain').value = state.templates.first.main || '';
        document.getElementById('firstRowTail').value = state.templates.first.tail || '';
        document.getElementById('cycleRow1Head').value = state.templates.cycle1.head || '';
        document.getElementById('cycleRow1Main').value = state.templates.cycle1.main || '';
        document.getElementById('cycleRow1Tail').value = state.templates.cycle1.tail || '';
        document.getElementById('cycleRow2Head').value = state.templates.cycle2.head || '';
        document.getElementById('cycleRow2Main').value = state.templates.cycle2.main || '';
        document.getElementById('cycleRow2Tail').value = state.templates.cycle2.tail || '';
    }
}


// --- UI AND CALCULATION FUNCTIONS (largely unchanged) ---

function updateTileLabels() {
    document.querySelectorAll('#tileTypesContainer .tile-type').forEach((div, index) => {
        const label = div.querySelector('label');
        const letter = String.fromCharCode(65 + index);
        label.textContent = `砖块 ${index + 1} (${letter}):`;
    });
}

function getBrickTypes() {
    const tileTypes = [];
    const brickMap = {};
    document.querySelectorAll('.tile-type').forEach((el, index) => {
        const width = parseFloat(el.querySelector('.tileWidth').value);
        const height = parseFloat(el.querySelector('.tileHeight').value);
        if (!isNaN(width) && !isNaN(height) && width > 0 && height > 0) {
            const letter = String.fromCharCode(65 + index);
            const tile = { letter, width, height, color: getRandomColor(index) };
            tileTypes.push(tile);
            brickMap[letter] = tile;
        }
    });
    return { tileTypes, brickMap };
}

function populateBrickSelects() {
    const { tileTypes } = getBrickTypes();
    const selects = document.querySelectorAll('#row-templates select');
    
    selects.forEach(sel => {
        const isMainBrick = sel.id.includes('Main');
        const selectedValue = sel.value;
        
        sel.innerHTML = '';
        sel.add(isMainBrick ? new Option('-- 请选择 --', '') : new Option('-- 无 --', ''));
        
        tileTypes.forEach(brick => {
            sel.add(new Option(`${brick.letter} (${brick.width} x ${brick.height})`, brick.letter));
        });
        
        sel.value = selectedValue;
    });
}

function generatePatternFromTemplate(template, brickMap, wallWidth) {
    const { head, main, tail } = template;
    if (!main) return { isValid: true, pattern: '', height: 0 };

    const headBrick = brickMap[head];
    const mainBrick = brickMap[main];
    const tailBrick = brickMap[tail];

    if (!mainBrick) return { isValid: false, error: "主循环砖未选择或无效。" };

    const patternHeight = mainBrick.height;
    if ((headBrick && headBrick.height !== patternHeight) || (tailBrick && tailBrick.height !== patternHeight)) {
        return { isValid: false, error: "模板中所有砖块的高度必须一致。" };
    }

    const remainingWidth = wallWidth - (headBrick?.width || 0) - (tailBrick?.width || 0);
    if (remainingWidth < 0) return { isValid: false, error: "头砖和尾砖的宽度已超出墙面总宽度。" };

    const mainCount = Math.floor(remainingWidth / mainBrick.width);
    const gap = remainingWidth - (mainCount * mainBrick.width);

    if (gap > 1) return { isValid: false, error: `砖块组合无法铺满整行，存在 ${gap.toFixed(1)} 的空隙。` };

    const pattern = (head || '') + main.repeat(mainCount) + (tail || '');
    return { isValid: true, pattern, height: patternHeight };
}

function calculateAndDraw() {
    const wallWidth = parseFloat(document.getElementById('wallWidth').value);
    const wallHeight = parseFloat(document.getElementById('wallHeight').value);

    if (isNaN(wallWidth) || isNaN(wallHeight)) return;

    const { tileTypes, brickMap } = getBrickTypes();
    if (tileTypes.length === 0) return;

    const templates = {
        first: { head: document.getElementById('firstRowHead').value, main: document.getElementById('firstRowMain').value, tail: document.getElementById('firstRowTail').value },
        cycle1: { head: document.getElementById('cycleRow1Head').value, main: document.getElementById('cycleRow1Main').value, tail: document.getElementById('cycleRow1Tail').value },
        cycle2: { head: document.getElementById('cycleRow2Head').value, main: document.getElementById('cycleRow2Main').value, tail: document.getElementById('cycleRow2Tail').value }
    };

    const firstResult = generatePatternFromTemplate(templates.first, brickMap, wallWidth);
    const cycle1Result = generatePatternFromTemplate(templates.cycle1, brickMap, wallWidth);
    const cycle2Result = generatePatternFromTemplate(templates.cycle2, brickMap, wallWidth);

    for (const result of [firstResult, cycle1Result, cycle2Result]) {
        if (!result.isValid) {
            document.getElementById('results-container').innerHTML = `<li>错误: ${result.error}</li>`;
            return;
        }
    }
    
    if (cycle1Result.pattern && cycle2Result.pattern && cycle1Result.height !== cycle2Result.height) {
         document.getElementById('results-container').innerHTML = `<li>错误: 循环行1和循环行2的高度必须一致。</li>`;
         return;
    }
    
    const placedTiles = [];
    const tileCounts = tileTypes.reduce((acc, t) => { acc[t.letter] = { ...t, count: 0 }; return acc; }, {});
    
    let currentY = wallHeight;

    if (firstResult.pattern && firstResult.height <= currentY) {
        let currentX = 0;
        for (const letter of firstResult.pattern) {
            const brick = brickMap[letter];
            placedTiles.push({ x: currentX, y: wallHeight - currentY, ...brick });
            tileCounts[letter].count++;
            currentX += brick.width;
        }
        currentY -= firstResult.height;
    }
    
    let cycleIndex = 0;
    while(currentY > 0 && cycle1Result.pattern && cycle2Result.pattern) {
        const result = (cycleIndex % 2 === 0) ? cycle1Result : cycle2Result;
        if (result.height <= 0 || result.height > currentY + 0.1) break;

        let currentX = 0;
        for (const letter of result.pattern) {
            const brick = brickMap[letter];
            placedTiles.push({ x: currentX, y: wallHeight - currentY, ...brick });
            tileCounts[letter].count++;
            currentX += brick.width;
        }
        currentY -= result.height;
        cycleIndex++;
    }

    drawWall(placedTiles, wallWidth, wallHeight);
    displayResults(tileCounts);
}

function drawWall(placedTiles, wallWidth, wallHeight) {
    const canvas = document.getElementById('wallCanvas');
    const ctx = canvas.getContext('2d');
    
    // 为尺寸标注留出边距
    const padding = { top: 40, right: 40, bottom: 50, left: 60 };
    
    const canvasContentWidth = canvas.width - padding.left - padding.right;
    const canvasContentHeight = canvas.height - padding.top - padding.bottom;

    const scale = Math.min(canvasContentWidth / wallWidth, canvasContentHeight / wallHeight);
    
    const scaledWidth = wallWidth * scale;
    const scaledHeight = wallHeight * scale;
    
    const offsetX = padding.left + (canvasContentWidth - scaledWidth) / 2;
    const offsetY = padding.top + (canvasContentHeight - scaledHeight) / 2;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // --- 绘制墙体和砖块 ---
    ctx.save();
    ctx.translate(offsetX, offsetY);
    
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, scaledWidth, scaledHeight);
    ctx.strokeStyle = '#333';
    ctx.strokeRect(0, 0, scaledWidth, scaledHeight);

    placedTiles.forEach(tile => {
        const tx = tile.x * scale;
        const ty = tile.y * scale;
        const tw = tile.width * scale;
        const th = tile.height * scale;
        ctx.fillStyle = tile.color;
        ctx.fillRect(tx, ty, tw, th);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(0.5, scale * 1.5);
        ctx.strokeRect(tx, ty, tw, th);
    });
    
    ctx.restore();

    // --- 绘制工程风格的尺寸标注 ---
    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#000';
    ctx.lineWidth = 1;
    ctx.font = '14px Arial';
    const tickSize = 8;
    const extensionGap = 8; // 墙体和尺寸界线之间的空隙
    const dimensionLineOffset = 20; // 尺寸线离墙体的距离

    // 绘制尺寸标记的函数 (斜线)
    const drawTick = (x, y, angle) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180);
        ctx.beginPath();
        ctx.moveTo(-tickSize / 2, tickSize / 2);
        ctx.lineTo(tickSize / 2, -tickSize / 2);
        ctx.stroke();
        ctx.restore();
    };

    // --- 绘制宽度尺寸 (底部) ---
    const yBottom = offsetY + scaledHeight;
    const yDimLine = yBottom + dimensionLineOffset;
    
    // 尺寸界线 (从墙角延伸)
    ctx.beginPath();
    ctx.moveTo(offsetX, yBottom);
    ctx.lineTo(offsetX, yDimLine + 5);
    ctx.moveTo(offsetX + scaledWidth, yBottom);
    ctx.lineTo(offsetX + scaledWidth, yDimLine + 5);
    ctx.stroke();

    // 尺寸线 (水平线)
    ctx.beginPath();
    ctx.moveTo(offsetX, yDimLine);
    ctx.lineTo(offsetX + scaledWidth, yDimLine);
    ctx.stroke();

    // 尺寸线两端的标记
    drawTick(offsetX, yDimLine, 45);
    drawTick(offsetX + scaledWidth, yDimLine, 45);

    // 宽度文字
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(wallWidth.toString()+'mm', offsetX + scaledWidth / 2, yDimLine - 4);

    // --- 绘制高度尺寸 (左侧) ---
    const xLeft = offsetX;
    const xDimLine = xLeft - dimensionLineOffset;

    // 尺寸界线 (从墙角延伸)
    ctx.beginPath();
    ctx.moveTo(xLeft, offsetY);
    ctx.lineTo(xDimLine - 5, offsetY);
    ctx.moveTo(xLeft, offsetY + scaledHeight);
    ctx.lineTo(xDimLine - 5, offsetY + scaledHeight);
    ctx.stroke();

    // 尺寸线 (垂直线)
    ctx.beginPath();
    ctx.moveTo(xDimLine, offsetY);
    ctx.lineTo(xDimLine, offsetY + scaledHeight);
    ctx.stroke();

    // 尺寸线两端的标记
    drawTick(xDimLine, offsetY, 45);
    drawTick(xDimLine, offsetY + scaledHeight, 45);
    
    // 高度文字 (旋转)
    ctx.save();
    ctx.translate(xDimLine - 8, offsetY + scaledHeight / 2);
    ctx.rotate(-Math.PI / 2); // 逆时针旋转90度
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(wallHeight.toString()+'mm', 0, 0);
    ctx.restore();
}

function displayResults(tileCounts) {
    const resultsContainer = document.getElementById('results-container');
    resultsContainer.innerHTML = '';
    
    Object.keys(tileCounts).sort().forEach(letter => {
        const data = tileCounts[letter];
        if (data.count > 0) {
            const name = `砖块 ${letter} (${data.width}x${data.height})`;
            const li = document.createElement('li');
            li.innerHTML = `<div class="color-box" style="background-color: ${data.color};"></div><span>${name}:</span><strong>${data.count} 块</strong>`;
            resultsContainer.appendChild(li);
        }
    });
    if (resultsContainer.innerHTML === '') {
        resultsContainer.innerHTML = '<li>没有铺设任何砖块。请定义并选择布局模式。</li>';
    }
}

function getRandomColor(seed) {
    const colors = ['#8ecae6', '#219ebc', '#023047', '#ffb703', '#fb8500', '#e63946', '#f1faee', '#a8dadc', '#457b9d', '#1d3557'];
    return colors[seed % colors.length];
}

</script>

</body>
</html>
